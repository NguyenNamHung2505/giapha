package com.familytree.service;

import com.familytree.dto.gedcom.GedcomImportResult;
import com.familytree.model.*;
import com.familytree.repository.FamilyTreeRepository;
import com.familytree.repository.IndividualRepository;
import com.familytree.repository.RelationshipRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.gedcom4j.model.*;
import org.gedcom4j.parser.GedcomParser;
import org.gedcom4j.writer.GedcomWriter;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.*;

/**
 * Service for importing and exporting GEDCOM files (gedcom4j 4.0.1 compatible)
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class GedcomService {

    private final FamilyTreeRepository treeRepository;
    private final IndividualRepository individualRepository;
    private final RelationshipRepository relationshipRepository;
    private final PermissionService permissionService;

    private static final int MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    private static final DateTimeFormatter[] DATE_FORMATTERS = {
            DateTimeFormatter.ofPattern("d MMM yyyy", Locale.ENGLISH),
            DateTimeFormatter.ofPattern("MMM yyyy", Locale.ENGLISH),
            DateTimeFormatter.ofPattern("yyyy")
    };

    /**
     * Import a GEDCOM file into a family tree
     */
    @Transactional
    public GedcomImportResult importGedcom(MultipartFile file, UUID treeId, UUID userId) {
        long startTime = System.currentTimeMillis();

        GedcomImportResult result = GedcomImportResult.builder()
                .treeId(treeId.toString())
                .build();

        try {
            // Validate file
            if (file.isEmpty()) {
                result.addError("File is empty");
                result.setSuccess(false);
                return result;
            }

            if (file.getSize() > MAX_FILE_SIZE) {
                result.addError("File size exceeds 10MB limit");
                result.setSuccess(false);
                return result;
            }

            String filename = file.getOriginalFilename();
            if (filename == null || !filename.toLowerCase().endsWith(".ged")) {
                result.addError("File must have .ged extension");
                result.setSuccess(false);
                return result;
            }

            // Verify tree ownership
            FamilyTree tree = treeRepository.findById(treeId)
                    .orElseThrow(() -> new RuntimeException("Tree not found"));

            if (!permissionService.canModifyTree(userId, treeId)) {
                result.addError("You don't have permission to modify this tree");
                result.setSuccess(false);
                return result;
            }

            // Parse GEDCOM file using BufferedInputStream
            log.info("Parsing GEDCOM file: {}", filename);
            GedcomParser parser = new GedcomParser();
            BufferedInputStream bis = new BufferedInputStream(file.getInputStream());
            parser.load(bis);

            // Check for parsing errors/warnings using getters
            List<String> errors = parser.getErrors();
            List<String> warnings = parser.getWarnings();

            if (!errors.isEmpty() || !warnings.isEmpty()) {
                errors.forEach(error -> {
                    log.warn("GEDCOM parse error: {}", error);
                    result.addError("Parse error: " + error);
                });
                warnings.forEach(warning -> {
                    log.info("GEDCOM parse warning: {}", warning);
                    result.addWarning("Warning: " + warning);
                });
            }

            Gedcom gedcom = parser.getGedcom();
            if (gedcom == null) {
                result.addError("Failed to parse GEDCOM file");
                result.setSuccess(false);
                return result;
            }

            // Process individuals
            Map<String, org.gedcom4j.model.Individual> gedcomIndividuals = gedcom.getIndividuals();
            log.info("Processing {} individuals", gedcomIndividuals.size());
            Map<String, com.familytree.model.Individual> individualMap = processIndividuals(gedcomIndividuals, tree, result);
            result.setIndividualsImported(individualMap.size());

            // Process families (relationships)
            Map<String, Family> gedcomFamilies = gedcom.getFamilies();
            log.info("Processing {} families", gedcomFamilies.size());
            List<Relationship> relationships = processFamilies(gedcomFamilies, individualMap, tree, result);
            result.setRelationshipsImported(relationships.size());

            result.setSuccess(true);
            log.info("GEDCOM import completed: {} individuals, {} relationships",
                    individualMap.size(), relationships.size());

        } catch (IOException e) {
            log.error("IO error reading GEDCOM file", e);
            result.addError("Failed to read file: " + e.getMessage());
            result.setSuccess(false);
        } catch (Exception e) {
            log.error("Unexpected error during GEDCOM import", e);
            result.addError("Unexpected error: " + e.getMessage());
            result.setSuccess(false);
        } finally {
            result.setProcessingTimeMs(System.currentTimeMillis() - startTime);
        }

        return result;
    }

    /**
     * Process GEDCOM individuals and save to database
     */
    private Map<String, com.familytree.model.Individual> processIndividuals(
            Map<String, org.gedcom4j.model.Individual> gedcomIndividuals,
            FamilyTree tree, GedcomImportResult result) {

        Map<String, com.familytree.model.Individual> individualMap = new HashMap<>();

        for (Map.Entry<String, org.gedcom4j.model.Individual> entry : gedcomIndividuals.entrySet()) {
            String xref = entry.getKey();
            org.gedcom4j.model.Individual gedcomIndividual = entry.getValue();

            try {
                com.familytree.model.Individual individual = com.familytree.model.Individual.builder()
                        .tree(tree)
                        .build();

                // Extract name using getter
                List<PersonalName> names = gedcomIndividual.getNames();
                if (names != null && !names.isEmpty()) {
                    PersonalName name = names.get(0);
                    StringWithCustomFacts givenName = name.getGivenName();
                    if (givenName != null) {
                        individual.setGivenName(givenName.getValue());
                    }
                    StringWithCustomFacts surname = name.getSurname();
                    if (surname != null) {
                        individual.setSurname(surname.getValue());
                    }
                }

                // Extract gender using getter
                StringWithCustomFacts sex = gedcomIndividual.getSex();
                if (sex != null && sex.getValue() != null) {
                    String sexValue = sex.getValue().toUpperCase();
                    if ("M".equals(sexValue)) {
                        individual.setGender(Gender.MALE);
                    } else if ("F".equals(sexValue)) {
                        individual.setGender(Gender.FEMALE);
                    } else {
                        individual.setGender(Gender.OTHER);
                    }
                }

                // Extract events using getter
                List<IndividualEvent> events = gedcomIndividual.getEvents();
                if (events != null) {
                    for (IndividualEvent event : events) {
                        IndividualEventType eventType = event.getType();
                        if (eventType == IndividualEventType.BIRTH) {
                            StringWithCustomFacts date = event.getDate();
                            if (date != null && date.getValue() != null) {
                                LocalDate birthDate = parseGedcomDate(date.getValue());
                                individual.setBirthDate(birthDate);
                            }
                            Place place = event.getPlace();
                            if (place != null && place.getPlaceName() != null) {
                                individual.setBirthPlace(place.getPlaceName());
                            }
                        } else if (eventType == IndividualEventType.DEATH) {
                            StringWithCustomFacts date = event.getDate();
                            if (date != null && date.getValue() != null) {
                                LocalDate deathDate = parseGedcomDate(date.getValue());
                                individual.setDeathDate(deathDate);
                            }
                            Place place = event.getPlace();
                            if (place != null && place.getPlaceName() != null) {
                                individual.setDeathPlace(place.getPlaceName());
                            }
                        }
                    }
                }

                // Save individual
                individual = individualRepository.save(individual);
                individualMap.put(xref, individual);

            } catch (Exception e) {
                log.error("Error processing individual {}: {}", xref, e.getMessage());
                result.addWarning("Failed to import individual " + xref + ": " + e.getMessage());
            }
        }

        return individualMap;
    }

    /**
     * Process GEDCOM families and create relationships
     */
    private List<Relationship> processFamilies(
            Map<String, Family> gedcomFamilies,
            Map<String, com.familytree.model.Individual> individualMap,
            FamilyTree tree, GedcomImportResult result) {

        List<Relationship> relationships = new ArrayList<>();

        for (Map.Entry<String, Family> entry : gedcomFamilies.entrySet()) {
            String xref = entry.getKey();
            Family family = entry.getValue();

            try {
                // Get spouses using getters
                com.familytree.model.Individual husband = null;
                com.familytree.model.Individual wife = null;

                org.gedcom4j.model.Individual husbandRef = family.getHusband();
                if (husbandRef != null) {
                    husband = individualMap.get(husbandRef.getXref());
                }

                org.gedcom4j.model.Individual wifeRef = family.getWife();
                if (wifeRef != null) {
                    wife = individualMap.get(wifeRef.getXref());
                }

                // Create spouse relationship
                if (husband != null && wife != null) {
                    Relationship spouseRel = Relationship.builder()
                            .tree(tree)
                            .individual1(husband)
                            .individual2(wife)
                            .type(RelationshipType.SPOUSE)
                            .build();

                    // Extract marriage event
                    List<FamilyEvent> familyEvents = family.getEvents();
                    if (familyEvents != null) {
                        for (FamilyEvent event : familyEvents) {
                            if (event.getType() == FamilyEventType.MARRIAGE) {
                                StringWithCustomFacts date = event.getDate();
                                if (date != null && date.getValue() != null) {
                                    LocalDate marriageDate = parseGedcomDate(date.getValue());
                                    spouseRel.setStartDate(marriageDate);
                                }
                            }
                        }
                    }

                    spouseRel = relationshipRepository.save(spouseRel);
                    relationships.add(spouseRel);
                }

                // Create parent-child relationships
                List<org.gedcom4j.model.Individual> children = family.getChildren();
                if (children != null) {
                    for (org.gedcom4j.model.Individual childRef : children) {
                        com.familytree.model.Individual child = individualMap.get(childRef.getXref());
                        if (child != null) {
                            // Father-child relationship
                            if (husband != null) {
                                Relationship fatherRel = Relationship.builder()
                                        .tree(tree)
                                        .individual1(husband)
                                        .individual2(child)
                                        .type(RelationshipType.PARENT_CHILD)
                                        .build();
                                fatherRel = relationshipRepository.save(fatherRel);
                                relationships.add(fatherRel);
                            }

                            // Mother-child relationship
                            if (wife != null) {
                                Relationship motherRel = Relationship.builder()
                                        .tree(tree)
                                        .individual1(wife)
                                        .individual2(child)
                                        .type(RelationshipType.PARENT_CHILD)
                                        .build();
                                motherRel = relationshipRepository.save(motherRel);
                                relationships.add(motherRel);
                            }
                        }
                    }
                }

            } catch (Exception e) {
                log.error("Error processing family {}: {}", xref, e.getMessage());
                result.addWarning("Failed to import family " + xref + ": " + e.getMessage());
            }
        }

        return relationships;
    }

    /**
     * Export a family tree to GEDCOM format
     */
    @Transactional(readOnly = true)
    public byte[] exportGedcom(UUID treeId, UUID userId) throws IOException {
        // Verify tree access
        FamilyTree tree = treeRepository.findById(treeId)
                .orElseThrow(() -> new RuntimeException("Tree not found"));

        if (!permissionService.canViewTree(userId, treeId)) {
            throw new RuntimeException("You don't have permission to view this tree");
        }

        // Create GEDCOM structure
        Gedcom gedcom = new Gedcom();
        gedcom.setHeader(new Header());
        gedcom.getHeader().setGedcomVersion(new GedcomVersion());
        gedcom.getHeader().getGedcomVersion().setVersionNumber(SupportedVersion.V5_5_1);

        SourceSystem sourceSystem = new SourceSystem();
        sourceSystem.setSystemId("Family Tree Manager");
        gedcom.getHeader().setSourceSystem(sourceSystem);

        gedcom.setSubmission(new Submission());
        gedcom.setTrailer(new Trailer());

        // Get all individuals and relationships
        List<com.familytree.model.Individual> individuals = individualRepository.findByTreeId(treeId);
        List<Relationship> relationships = relationshipRepository.findByTreeId(treeId);

        // Map our individuals to GEDCOM individuals
        Map<UUID, org.gedcom4j.model.Individual> gedcomIndividualMap = new HashMap<>();

        for (com.familytree.model.Individual ind : individuals) {
            String xref = "@I" + ind.getId().toString().replace("-", "").substring(0, 8) + "@";
            org.gedcom4j.model.Individual gedcomInd = new org.gedcom4j.model.Individual(xref);

            // Name
            PersonalName name = new PersonalName();
            StringBuilder nameValue = new StringBuilder();
            if (ind.getGivenName() != null) {
                nameValue.append(ind.getGivenName());
            }
            if (ind.getSurname() != null) {
                if (nameValue.length() > 0) nameValue.append(" ");
                nameValue.append("/").append(ind.getSurname()).append("/");
            }
            name.setBasic(nameValue.toString().trim());

            if (ind.getGivenName() != null) {
                name.setGivenName(new StringWithCustomFacts(ind.getGivenName()));
            }
            if (ind.getSurname() != null) {
                name.setSurname(new StringWithCustomFacts(ind.getSurname()));
            }

            gedcomInd.getNames(true).add(name);

            // Gender
            if (ind.getGender() != null) {
                gedcomInd.setSex(new StringWithCustomFacts(
                        ind.getGender() == Gender.MALE ? "M" :
                        ind.getGender() == Gender.FEMALE ? "F" : "U"
                ));
            }

            // Birth event
            if (ind.getBirthDate() != null || ind.getBirthPlace() != null) {
                IndividualEvent birth = new IndividualEvent();
                birth.setType(IndividualEventType.BIRTH);
                if (ind.getBirthDate() != null) {
                    birth.setDate(new StringWithCustomFacts(formatGedcomDate(ind.getBirthDate())));
                }
                if (ind.getBirthPlace() != null) {
                    Place place = new Place();
                    place.setPlaceName(ind.getBirthPlace());
                    birth.setPlace(place);
                }
                gedcomInd.getEvents(true).add(birth);
            }

            // Death event
            if (ind.getDeathDate() != null || ind.getDeathPlace() != null) {
                IndividualEvent death = new IndividualEvent();
                death.setType(IndividualEventType.DEATH);
                if (ind.getDeathDate() != null) {
                    death.setDate(new StringWithCustomFacts(formatGedcomDate(ind.getDeathDate())));
                }
                if (ind.getDeathPlace() != null) {
                    Place place = new Place();
                    place.setPlaceName(ind.getDeathPlace());
                    death.setPlace(place);
                }
                gedcomInd.getEvents(true).add(death);
            }

            gedcom.getIndividuals().put(xref, gedcomInd);
            gedcomIndividualMap.put(ind.getId(), gedcomInd);
        }

        // Process relationships and create families
        Map<String, Family> familyMap = new HashMap<>();

        for (Relationship rel : relationships) {
            if (rel.getType() == RelationshipType.SPOUSE) {
                String familyId = "@F" + rel.getId().toString().replace("-", "").substring(0, 8) + "@";
                Family family = familyMap.computeIfAbsent(familyId, k -> new Family(k));

                org.gedcom4j.model.Individual ind1 = gedcomIndividualMap.get(rel.getIndividual1().getId());
                org.gedcom4j.model.Individual ind2 = gedcomIndividualMap.get(rel.getIndividual2().getId());

                if (ind1 != null && ind2 != null) {
                    if (rel.getIndividual1().getGender() == Gender.MALE) {
                        family.setHusband(ind1);
                        family.setWife(ind2);
                    } else {
                        family.setHusband(ind2);
                        family.setWife(ind1);
                    }

                    // Marriage event
                    if (rel.getStartDate() != null) {
                        FamilyEvent marriage = new FamilyEvent();
                        marriage.setType(FamilyEventType.MARRIAGE);
                        marriage.setDate(new StringWithCustomFacts(formatGedcomDate(rel.getStartDate())));
                        family.getEvents(true).add(marriage);
                    }
                }
            }
        }

        // Add children to families
        for (Relationship rel : relationships) {
            if (rel.getType() == RelationshipType.PARENT_CHILD) {
                org.gedcom4j.model.Individual parent = gedcomIndividualMap.get(rel.getIndividual1().getId());
                org.gedcom4j.model.Individual child = gedcomIndividualMap.get(rel.getIndividual2().getId());

                if (parent != null && child != null) {
                    // Find family where parent is husband or wife
                    Family family = null;
                    for (Family f : familyMap.values()) {
                        if ((f.getHusband() != null && f.getHusband().equals(parent)) ||
                            (f.getWife() != null && f.getWife().equals(parent))) {
                            family = f;
                            break;
                        }
                    }

                    if (family != null) {
                        family.getChildren(true).add(child);
                    }
                }
            }
        }

        // Add families to gedcom
        gedcom.getFamilies().putAll(familyMap);

        // Write GEDCOM to byte array
        GedcomWriter writer = new GedcomWriter(gedcom);
        writer.setValidationSuppressed(false);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        writer.write(baos);
        return baos.toByteArray();
    }

    /**
     * Parse GEDCOM date string to LocalDate
     */
    private LocalDate parseGedcomDate(String gedcomDate) {
        if (gedcomDate == null || gedcomDate.trim().isEmpty()) {
            return null;
        }

        // Remove qualifiers like ABT, BEF, AFT, etc.
        String cleanDate = gedcomDate.replaceAll("(?i)(ABT|BEF|AFT|CAL|EST|BET|AND)\\s+", "").trim();

        // Try different date formats
        for (DateTimeFormatter formatter : DATE_FORMATTERS) {
            try {
                return LocalDate.parse(cleanDate, formatter);
            } catch (DateTimeParseException e) {
                // Try next formatter
            }
        }

        // Try to extract just the year
        try {
            int year = Integer.parseInt(cleanDate);
            return LocalDate.of(year, 1, 1);
        } catch (NumberFormatException e) {
            log.warn("Could not parse date: {}", gedcomDate);
            return null;
        }
    }

    /**
     * Format LocalDate to GEDCOM date string
     */
    private String formatGedcomDate(LocalDate date) {
        if (date == null) {
            return "";
        }
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("d MMM yyyy", Locale.ENGLISH);
        return date.format(formatter).toUpperCase();
    }
}
